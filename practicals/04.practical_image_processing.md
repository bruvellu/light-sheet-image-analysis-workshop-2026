# Introduction to Thresholding in Fiji

In this exercise we will:

- Compare global and local thresholding methods and understand when each is useful.  
- Improve segmentation using background subtraction and Gaussian smoothing.  
- Refine masks using binary operations, including **Fill Holes** and **Kill Borders**.  
- Generate labeled objects using MorphoLibJ's Connected Components Labeling.  
- Extract object-level measurements (area, perimeter, circularity, etc.).  
- Visualize measurement values on labeled images.  
- Filter segmented objects based on size or other properties.  

These steps form a complete workflow:  
**from raw image → segmentation → cleanup → labeling → measurement → filtered results.**

We’ll use `MAX_Lund.tif` as the example image.

---

## 1. Open the image and inspect the histogram

1. Start **Fiji**.
2. Open the image  
   `File → Open… → MAX_Lund.tif`
   ![Brightness/Contrast histogram](images/MAX_Lund.png)
4. Open the Brightness & Contrast window:  
   `Image → Adjust → Brightness/Contrast…`

You should see a histogram like this:

![Brightness/Contrast histogram](images/04.Screenshot1.png)

**Idea:** thresholding is just choosing an intensity value that separates “foreground” (objects) from “background”. The histogram shows how many pixels have each intensity; a threshold is one vertical cut in this histogram.

---

## 2. Try all global Auto Threshold methods

Global thresholding uses **one single threshold value for the whole image**.

1. With `MAX_Lund.tif` active, run:  
   `Image → Adjust → Auto Threshold…`
2. In the dialog:
   - Choose `Method: Try all`
   - Set `White objects` (so objects will be white on black background)
   - Confirm.

Fiji will generate a montage showing the result of each global method, similar to:

![Global auto threshold montage](images/04.AutoThresh.tif)

Look at how different methods handle background, noise, and object boundaries. All of them use a **single** threshold value across the whole image.

---

## 3. Prepare the image for Auto Local Threshold

Local thresholding in Fiji requires an **8-bit** image.

1. Select the original image again:  
   `Window → MAX_Lund.tif`
2. Convert to 8-bit:  
   `Image → Type → 8-bit`  
   (If needed, enable scaling via `Edit → Options → Conversions…` and tick *Scale when converting*.)

Now the image is ready for local thresholding.

---

## 4. Try all Auto Local Threshold methods

Local thresholding computes a **different threshold in each neighborhood** (e.g. within a radius of 15 pixels). This adapts to uneven illumination and local contrast.

1. Run:  
   `Plugins → Auto Local Threshold…`  
   (or `Image → Adjust → Auto Local Threshold…` depending on your Fiji version)
2. In the dialog:
   - `Method: Try all`
   - `Radius: 15`
   - `Parameter 1: 0`
   - `Parameter 2: 0`
   - `White objects`
3. Confirm.

Fiji will generate a montage with all local methods:

![Local auto threshold montage](images/04.AutoLocalThresh1.tif)

Compare these results to the global methods. Local methods often segment structures better when the background is uneven or objects have varying brightness.

## 5. Improving segmentation with background subtraction and smoothing

Sometimes segmentation improves if we reduce background and noise before thresholding. Here we apply a rolling-ball background subtraction and a small Gaussian blur to the raw image, and then compare results.

### 5.1 Remove background and apply Gaussian blur

1. Open `MAX_Lund.png`.
2. Run **Subtract Background…** with a rolling ball radius of **50**.  
3. Save the background-corrected image as `MAX_Lund_Bkg.png`.
4. Apply **Gaussian Blur…** with **sigma = 1** to smooth noise.

After preprocessing, we run **Auto Local Threshold (Try all)** again to compare the effect of background removal and smoothing.

**Results after preprocessing:**

![Auto Local Threshold after preprocessing](images/AutoLocalThresh2.tif)

---

## 6. Selecting a method: Local Otsu and binary cleanup

From the local thresholding methods, we now choose **Otsu** with a radius of 15 and generate a cleaner binary mask.

### 6.1 Apply Local Otsu

1. Open `MAX_Lund_Bkg.png`.
2. Run **Auto Local Threshold** with:
   - Method: **Otsu**  
   - Radius: **15**  
3. Save the result as `MAX_Lund_Mask.png`.

**Local Otsu mask:**

![Local Otsu mask](images/MAX_Lund_Mask.png)

---

### 6.2 Clean the mask with binary operations

Binary operations allow us to refine the segmentation (e.g., separating touching objects or removing noise).

1. Ensure **Process → Binary → Options… → Black background** is enabled.  
2. Run **Erode** to slightly shrink objects and break small connections.  
3. Optionally draw/restore edges or boundaries if needed.  
4. Run **Dilate** to grow objects back after erosion.  
5. Save the final mask as `MAX_Lund_MaskErode.png`.

**Refined mask after binary operations:**

![Refined mask](images/MAX_Lund_MaskErode.png)

In addition to *Erode* and *Dilate*, we now also apply **Fill Holes**, which fills empty pixels inside objects.

1. Run **Fill Holes** to ensure each object is internally solid.  
2. Run **Kill Borders** to remove partial objects touching the border.  
3. Save the result as `MAX_Lund_Mask-killBorders.png`.  
4. If useful, apply **Erode** and **Dilate** to further separate or regularize objects.

**Result after filling holes and removing border objects:**

![Filled + border-removed mask](images/MAX_Lund_Mask-killBorders.png)


## 7. Object labeling with MorphoLibJ

Once we have a clean binary mask, the next step is to turn each connected region into a uniquely labeled object.  
This gives us a “segmentation map” where each detected structure receives its own ID.

We use **Connected Components Labeling**, which assigns a different label value to every object.

**Labeled objects (each with a unique color):**

![Connected components labeling](images/MAX_Lund_Mask-killBorders-lbl.png)

## 8. Measuring object properties

After labeling, we can extract quantitative features of each object.  
This is important because segmentation is usually not the end goal — the goal is to *measure* something.

Using **Analyze Regions** (MorphoLibJ), we obtain:

- Area and pixel count  
- Perimeter  
- Circularity / shape descriptors  
- Ellipse fitting (center, elongation)  
- Bounding box geometry  

These values appear as a table:

![Morphometry table](images/Screenshot2.png)

Such measurements allow downstream analysis such as size distributions, morphology comparisons, or filtering objects based on properties.

## 9. Visualizing label properties

Before filtering or removing any objects, it is useful to visualize a specific measurement across all labeled regions.  
This helps confirm that the segmentation is meaningful and that measurements behave as expected.

Using MorphoLibJ, we can map any measurement (e.g., area, circularity, elongation) onto the labeled image.  
Each object is then colored according to its numeric value.

Here we visualize the **Area** of each object using a viridis colormap:

![Area visualization on labels](images/MAX_Lund_Mask-killBorders-lbl-Area.png)

Such visual maps are helpful for:

- spotting unusually large or small objects  
- deciding appropriate thresholds for filtering  
- checking whether measurements reflect true object morphology  


## 10. Filtering objects by size

MorphoLibJ also allows filtering objects according to measured properties.  
A common step is removing very small or noise-like detections.

Using **Label Size Filtering**, we keep only objects above a chosen size threshold (e.g., 100 px).

**Result after removing small objects:**

![Size filtering](images/MAX_Lund_Mask-killBorders-lbl-sizeFilt.png)


---

# Image processing, denoising, segmentation

Marina (1 hs)
- Segmentation, post-processing, Morphological operations, Labeling (MorphoLibJ in Fiji)
  
  https://knowhowspot.blog/fiji-morphological-segmentation-plugin-guide
- Napari assistant (MC I could do it based on RH talk - 30 min)

